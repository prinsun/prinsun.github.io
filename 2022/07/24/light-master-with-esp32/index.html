<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.png">
  <link rel="mask-icon" href="/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.makeex.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="怕什么真理无穷，进一寸有一寸的欢喜。  在不间断的核酸和反思中又过去了一周，看了看修炼 点灯大师 的路途，还很遥远，本打算就这样浑浑噩噩的度过这个周末，但心中的灯还亮着，手上的灯又有什么理由不让它亮起来呢？ 上一期我们探讨了下古老的 51 单片机，并借机铺垫了很多嵌入式开发的基础知识，今天我们来看一款更加现代化的 MCU — ESP32，这是我所接触到的第一款国产芯片，我愿称之为“国货之光”！">
<meta property="og:type" content="article">
<meta property="og:title" content="点灯大师在线点灯之 ESP32">
<meta property="og:url" content="http://blog.makeex.com/2022/07/24/light-master-with-esp32/index.html">
<meta property="og:site_name" content="MakeeX">
<meta property="og:description" content="怕什么真理无穷，进一寸有一寸的欢喜。  在不间断的核酸和反思中又过去了一周，看了看修炼 点灯大师 的路途，还很遥远，本打算就这样浑浑噩噩的度过这个周末，但心中的灯还亮着，手上的灯又有什么理由不让它亮起来呢？ 上一期我们探讨了下古老的 51 单片机，并借机铺垫了很多嵌入式开发的基础知识，今天我们来看一款更加现代化的 MCU — ESP32，这是我所接触到的第一款国产芯片，我愿称之为“国货之光”！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.makeex.com/images/2022/07/24/01-esp32_board.png">
<meta property="og:image" content="http://blog.makeex.com/images/2022/07/24/02-uart-output.png">
<meta property="og:image" content="http://blog.makeex.com/images/2022/07/24/03-rgb-sch.png">
<meta property="og:image" content="http://blog.makeex.com/images/2022/07/24/04-ws2812-sg.png">
<meta property="og:image" content="http://blog.makeex.com/images/2022/07/24/05-ws2812-sf.png">
<meta property="og:image" content="http://blog.makeex.com/images/2022/07/24/06-lighting.png">
<meta property="og:image" content="http://blog.makeex.com/images/2022/07/24/07-online-con.png">
<meta property="article:published_time" content="2022-07-24T14:22:22.000Z">
<meta property="article:modified_time" content="2022-07-30T04:21:07.300Z">
<meta property="article:author" content="Makee">
<meta property="article:tag" content="Light Master">
<meta property="article:tag" content="ESP32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.makeex.com/images/2022/07/24/01-esp32_board.png">

<link rel="canonical" href="http://blog.makeex.com/2022/07/24/light-master-with-esp32/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>点灯大师在线点灯之 ESP32 | MakeeX</title>
  


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b46a193b288b66b7eb9dc75b4d74eae6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MakeeX</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/prinsun" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.makeex.com/2022/07/24/light-master-with-esp32/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Makee">
      <meta itemprop="description" content="LIFE IS NOT EASY BUT HARD WORK ALWAYS PAYS.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MakeeX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          点灯大师在线点灯之 ESP32
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-24 22:22:22" itemprop="dateCreated datePublished" datetime="2022-07-24T22:22:22+08:00">2022-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-Development/" itemprop="url" rel="index"><span itemprop="name">Embedded Development</span></a>
                </span>
            </span>

          
            <span id="/2022/07/24/light-master-with-esp32/" class="post-meta-item leancloud_visitors" data-flag-title="点灯大师在线点灯之 ESP32" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论总数：</span>
    
    <a title="valine" href="/2022/07/24/light-master-with-esp32/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/24/light-master-with-esp32/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>怕什么真理无穷，进一寸有一寸的欢喜。</p>
</blockquote>
<p>在不间断的核酸和反思中又过去了一周，看了看修炼 <strong>点灯大师</strong> 的路途，还很遥远，本打算就这样浑浑噩噩的度过这个周末，但心中的灯还亮着，手上的灯又有什么理由不让它亮起来呢？</p>
<p>上一期我们探讨了下古老的 51 单片机，并借机铺垫了很多嵌入式开发的基础知识，今天我们来看一款更加现代化的 MCU — ESP32，这是我所接触到的第一款国产芯片，我愿称之为“国货之光”！</p>
<span id="more"></span>

<h1 id="ESP32-简介"><a href="#ESP32-简介" class="headerlink" title="ESP32 简介"></a>ESP32 简介</h1><p>ESP32 是由乐鑫生产的一系列国产芯片，相比于国外的芯片，最最直接的优点就<strong>性价比</strong>，同等级别的芯片，ESP32 的价格可能是国外芯片的一半都不到。以下是一些比较官方的介绍：</p>
<blockquote>
<p>ESP32 是乐鑫信息科技推出的一块 WIFI 芯片，集成了天线开关、射频、功率放大器、低噪放大器、过滤器和电源管理模块，整个解决方案占用了最少的印刷电路板面积。2.4 GHz Wi-Fi 加蓝牙双模芯片采用 TSMC 低功耗 40nm 技术，功耗性能和射频性能最佳，安全可靠，易于扩展至各种应用。具有以下特点：</p>
<ul>
<li>性价比高</li>
<li>体积小</li>
<li>功能强大，支持 LWIP 协议，FreeRTOS</li>
<li>支持三种模式：AP, STA, AP + STA 共存模式</li>
<li>支持 Python、Lua 编程，让你开发更简单</li>
</ul>
</blockquote>
<p>在上面的介绍里可以看到，通过烧录一些特定固件，可以支持 Python、Lua 编程，也就是说我们可以通过 Python、Lua 来进行点灯，但这不在我们修炼的范围 (<em>不要迷恋这些旁门左道！</em>)，毕竟这些都是给小孩子玩的，成年人的灯还是要用成年人的方式来点。</p>
<h1 id="开发板简介"><a href="#开发板简介" class="headerlink" title="开发板简介"></a>开发板简介</h1><p>截止本篇文章发表前，ESP 一共有以下系列：</p>
<ul>
<li>ESP32-S2</li>
<li>ESP32-S3</li>
<li>ESP32-C2</li>
<li>ESP32-C3</li>
<li>ESP32</li>
<li>ESP8266</li>
</ul>
<p>其中 ESP8266 是最早出名的一款芯片，因为价格便宜且带 WiFi 功能，很多硬件方案里并不将其作为主控芯片，而是单纯的当成 WiFi 模块来进行使用 (<em>尴尬的地位啊！</em>)。经历了 ESP8266 之后，ESP32 登场，这应该是目前大家所讨论的广义上的 ESP32 了，同样的价格低廉，外加蓝牙、WIFi 应有尽有，并且还是双核结构，性价比简直无与伦比了。后续又推出了 C 和 S 系列的 ESP32，C 系列算是对 ESP32 进行了阉割，更低的价格、更低的功耗；而 S 是对 ESP32 的增强，价格贵一点、能力强一点。</p>
<p>今天我们要探讨的是经典的 ESP32，也就是基于 Xtensa 双核 32 位 LX6 微处理器的这款。上一期我们说过了，有了 MCU 还需要一些外围电路来驱动，也就是需要开发板。ESP32 的开发板某宝里到处都是，以下是我手头上的一款：</p>
<p><img data-src="/images/2022/07/24/01-esp32_board.png"></p>
<p>开发板下面是 iPhone 6s，对比可以看到这款板子是非常小巧的，当然板载的东西就要少很多了 (<em>相比上期的 51 单片机开发板</em>)，不过灯还是有的，对于修炼点灯而言，我们要求的板载外设并不多，只要有灯就够了！</p>
<h1 id="点灯几种方式"><a href="#点灯几种方式" class="headerlink" title="点灯几种方式"></a>点灯几种方式</h1><p>在正式点灯之前，我们要先聊聊能有哪些方式来点灯 (<em>茴字的写法？</em>)，这也是上期在讲 51 单片机时没有涉及的。本篇开头部分就已经说了，相比于 51 而言，ESP32 是一个更加现代化的 MCU，那么它现代化在哪呢？</p>
<ol>
<li>从 8 位到 32 位，拥有更为广泛的编址空间，寄存器数量庞大。寄存器也变为了 32 位，单个寄存器的可配置项更多</li>
<li>从 单核 到 双核，更为复杂的启动逻辑，并行计算成为可能</li>
<li>从 裸机 到 系统，ESP32 支持实时操作系统，使用起来更方便，但底层逻辑更复杂</li>
<li>从 双向 到 单向，这是从 GPIO 的角度而言，在 51 的时代，GPIO 任何时候都是双向的，也就是即是输入也是输出 (<em>这会造成一些困扰</em>)，而 ESP32 和一些其他更为现代化的 MCU 一样，需要进行配置是输入输出模式</li>
</ol>
<p>总体而言，强大了很多，也复杂了很多。这也让我们的点灯方式上有了更多选择，本篇将用以下几种方式来进行点灯：</p>
<ol>
<li>类似与 51 单片机的纯寄存器点灯</li>
<li>使用官方的 IDF 框架来进行点灯</li>
<li>使用 Arduino 框架来进行点灯</li>
</ol>
<p>那么最贴近底层，也最为复杂的就是第一种点灯方式了，既然是修炼点灯，这是不可或缺的。这种纯寄存器的开发方式，在嵌入式开发中又称之为 <strong>裸机开发</strong>，所谓的裸机，就是指没有任何操作系统的情况下。</p>
<h1 id="启动流程分析"><a href="#启动流程分析" class="headerlink" title="启动流程分析"></a>启动流程分析</h1><p>在任何 MCU、CPU 进行裸机开发的第一步，都是需要了解下整个芯片是怎么运作起来的，也就是从上电到程序运行起来的整个流程。这在不同的 SoC 下不太一样，但总体而言都大同小异，也就是了解了 ESP32 的启动逻辑，对了解其它更为复杂的 CPU 启动逻辑也是有一定帮助的。</p>
<p>从宏观上 (<em>也就是基于官方的 IDF 开发流程</em>)，ESP32 启动流程可以分为如下 3 个步骤：</p>
<ol>
<li>一级引导程序被固化在了 ESP32 内部的 ROM 中，它会从 Flash 的 <code>0x1000</code> 偏移地址处加载二级引导程序至 RAM(IRAM &amp; DRAM) 中</li>
<li>二级引导程序从 Flash 中加载分区表和主程序镜像至内存中，主程序中包含了 RAM 段和通过 Flash 高速缓存映射的只读段</li>
<li>主程序运行，这时第二个 CPU 和 RTOS 的调度器可以开始运行</li>
</ol>
<p>标准流程里包含了两次引导和一些初始化过程，相对而言还是比较简单的。为了和官方参考手册中一致，我们也将 ESP32 的两个处理器内核分为 PRO CPU 和 APP CPU，需要注意的是，整个启动过程中只有 PRO CPU 在工作，到达第三步时才开启了 APP CPU。</p>
<p>首先是一级引导程序，这个是乐鑫官方固化在 ROM 里了，也就是说我们是没有源码也无法修改的。SoC 复位以后，PRO CPU 会立即开始运行，执行复位向量代码，复位向量代码位于 ESP32 芯片掩膜 ROM 的 <code>0x40000400</code> 地址处，该地址不能被修改。复位向量里的代码，会通过检测相关寄存器来判断复位源，从而进入不同的启动模式，比如进入下载模式 (<em>可通过串口烧录二进制文件到 MCU 里</em>)，如果是常规的软件复位或看门狗复位，则会从 Flash 的 <code>0x1000</code> 偏移地址处加载二进制镜像，这里通常就是放置二级引导程序的位置了。当然，一级引导程序还做了些额外的事情：</p>
<ol>
<li>初始化了栈指针 sp，所以我们可以直接用 C 语言了</li>
<li>开启了看门狗：在 Flash 启动过程中，定时器组 0(TIMG0)中的 MWDT 和 RWDT 自动使能。两个看门狗定时器的阶段 0 默认为在超时后复位系统</li>
<li>包含了一些实用的 C 函数，我们可以将其导出后直接使用</li>
</ol>
<p>再看看二级引导程序，这段程序是开源的，也可以说是传统意义上的 bootloader 了，二级引导程序的代码在 IDF 框架的：components&#x2F;bootloader 以及 components&#x2F;bootloader_support 这两个文件夹里。可以说 bootloader 就是一个比较复杂的裸机程序，所以我们要编写的裸机程序完全可以参照这个 bootloader 来。</p>
<h1 id="构建编译环境"><a href="#构建编译环境" class="headerlink" title="构建编译环境"></a>构建编译环境</h1><p>那么问题就很简单了，一级引导在正常模式下，会从 Flash 的 <code>0x1000</code> 加载二进制镜像，那么我们将裸机程序放在这个位置岂不是就能自动执行了？大致是这样，但又不能直接这样，因为我们最终会通过交叉编译器来编译代码，现代化的嵌入式开发基本都是使用 GNU 那一套 GCC 交叉编译，直接编译出来的产物是 ELF 格式的文件，这个文件是不能被 ESP32 直接加载执行的。ESP32 能加载执行的文件格式定义在了 <code>esp_app_format.h</code> 这个头文件里，也比较简单，主要包含文件头信息以及其它节点布局信息，头信息的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> magic;              <span class="comment">/*!&lt; Magic word ESP_IMAGE_HEADER_MAGIC */</span></span><br><span class="line">    <span class="type">uint8_t</span> segment_count;      <span class="comment">/*!&lt; Count of memory segments */</span></span><br><span class="line">    <span class="type">uint8_t</span> spi_mode;           <span class="comment">/*!&lt; flash read mode (esp_image_spi_mode_t as uint8_t) */</span></span><br><span class="line">    <span class="type">uint8_t</span> spi_speed: <span class="number">4</span>;       <span class="comment">/*!&lt; flash frequency (esp_image_spi_freq_t as uint8_t) */</span></span><br><span class="line">    <span class="type">uint8_t</span> spi_size: <span class="number">4</span>;        <span class="comment">/*!&lt; flash chip size (esp_image_flash_size_t as uint8_t) */</span></span><br><span class="line">    <span class="type">uint32_t</span> entry_addr;        <span class="comment">/*!&lt; Entry address */</span></span><br><span class="line">    <span class="type">uint8_t</span> wp_pin;            <span class="comment">/*!&lt; WP pin when SPI pins set via efuse (read by ROM bootloader,</span></span><br><span class="line"><span class="comment">                                * the IDF bootloader uses software to configure the WP</span></span><br><span class="line"><span class="comment">                                * pin and sets this field to 0xEE=disabled) */</span></span><br><span class="line">    <span class="type">uint8_t</span> spi_pin_drv[<span class="number">3</span>];     <span class="comment">/*!&lt; Drive settings for the SPI flash pins (read by ROM bootloader) */</span></span><br><span class="line">    <span class="type">esp_chip_id_t</span> chip_id;      <span class="comment">/*!&lt; Chip identification number */</span></span><br><span class="line">    <span class="type">uint8_t</span> min_chip_rev;       <span class="comment">/*!&lt; Minimum chip revision supported by image */</span></span><br><span class="line">    <span class="type">uint8_t</span> reserved[<span class="number">8</span>];       <span class="comment">/*!&lt; Reserved bytes in additional header space, currently unused */</span></span><br><span class="line">    <span class="type">uint8_t</span> hash_appended;      <span class="comment">/*!&lt; If 1, a SHA256 digest &quot;simple hash&quot; (of the entire image) is appended after the checksum.</span></span><br><span class="line"><span class="comment">                                 * Included in image length. This digest</span></span><br><span class="line"><span class="comment">                                 * is separate to secure boot and only used for detecting corruption.</span></span><br><span class="line"><span class="comment">                                 * For secure boot signed images, the signature</span></span><br><span class="line"><span class="comment">                                 * is appended after this (and the simple hash is included in the signed data). */</span></span><br><span class="line">&#125; __attribute__((packed))  <span class="type">esp_image_header_t</span>;</span><br></pre></td></tr></table></figure>

<p>在 ESP32 这款 MCU 里，<code>magic</code> 固定是 <code>0xE9</code>，在 C 或 S 系列下可能不一样，我们可以通过 <code>hexdump</code> 一个编译好的 bin 文件信息:</p>
<pre><code> hexdump -Cn 32 test.bin
</code></pre>
<p>输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000  e9 02 02 10 24 04 08 40  ee 00 00 00 00 00 00 00  |�...$..@�.......|</span><br><span class="line">00000010  00 00 00 00 00 00 00 01  00 00 ff 3f 1c 00 00 00  |..........�?....|</span><br><span class="line">00000020</span><br></pre></td></tr></table></figure>

<p>上一期在 51 烧录部分我们使用了自己的烧录工具 burnit，这个工具其实也支持 ESP32 的烧录，但是没有进行 ELF 转 ESP32 镜像格式的功能，这个等后续有时间再加入。这一期我们就直接用乐鑫官方的工具来进行操作吧，环境安装的话参考官网，这里就不赘述了。可以通过以下命令将 ELF 转为 ESP32 支持的镜像 (<em>Flash 相关参数根据自己的芯片自行调整</em>)：</p>
<pre><code>esptool.py --chip esp32 elf2image \
           --flash_mode dio       \
           --flash_freq 40m       \
           --flash_size 2MB       \
           -o &lt;输出的BIN文件&gt; &lt;输入的ELF文件&gt;
</code></pre>
<h2 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h2><p>有了上述工具，我们将直接编译出来的 ELF 转成 BIN 文件的话，ESP32 依然是无法正确执行的，因为需要正确的内存布局。所谓内存布局，就是代码也从哪里<strong>开始</strong>运行，以及最终要被加载到哪个位置，这是需要在链接阶段进行确定的，而要能指定正确的位置我们还需要参考官方手 IDF 的 bootloader 来：</p>
<blockquote>
<ul>
<li>内部 SRAM0 区域的一部分分配为指令 RAM。除了开始的 64kB 用作 PRO CPU 和 APP CPU 的高速缓存外，剩余内存区域（从 <code>0x40080000</code> 至 <code>0x400A0000</code> ）被用来存储应用程序中部分需要在RAM中运行的代码。</li>
<li>链接器将非常量静态数据和零初始化数据放入 <code>0x3FFB0000</code> — <code>0x3FFF0000</code> 这 256kB 的区域。注意，如果使用蓝牙堆栈，此区域会减少 64kB（通过将起始地址移至 0x3FFC0000 ）</li>
</ul>
</blockquote>
<p>还那我们可以将指令存储在 SRAM 里的：<code>0x40080000</code> - <code>0x400A0000</code> 这个区域，静态常量和数据存储在 <code>0x3FFB0000</code> - <code>0x3FFF0000</code> 这个区域 (<em>没有使用蓝牙和内存追踪</em>)。注意这里指定的都是程序运行时的地址，我们最终的程序还是烧录到 Flash 的 <code>0x1000</code> 这个偏移地址，那最终程序是怎么跑到这些指定的地址上了呢？这就是一级引导程序干的事情了 (<em>搬运工</em>)。确定了这些地址，我们就可以构建链接脚本了，链接脚本的语法这里不展开，涉及到的面比较多 (<em>主要是编译后的代码段如何分配</em>)，没有接触过的话，可以自行搜索学习下，以下是我们的链接脚本：</p>
<figure class="highlight plaintext"><figcaption><span>esp32.lds</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">  iram_seg (RWX):  org = 0x40080000, len = 0x20000 </span><br><span class="line">  dram_seg (RW) :  org = 0x3FFB0000, len = 0x40000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENTRY(main);</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .text : &#123;</span><br><span class="line">    *(.literal .text .literal.* .text.* .stub .gnu.warning .gnu.linkonce.literal.* .gnu.linkonce.t.*.literal .gnu.linkonce.t.*)</span><br><span class="line">    *(.fini.literal)</span><br><span class="line">    *(.fini)</span><br><span class="line">    *(.gnu.version)</span><br><span class="line">    . += 16;</span><br><span class="line">  &#125; &gt; iram_seg</span><br><span class="line"></span><br><span class="line">  .rodata : &#123;</span><br><span class="line">    *(.rodata)</span><br><span class="line">    *(.rodata.*)</span><br><span class="line">    *(.gnu.linkonce.r.*)</span><br><span class="line">    *(.rodata1)</span><br><span class="line">    *(*.lit4)</span><br><span class="line">    *(.lit4.*)</span><br><span class="line">    *(.gnu.linkonce.lit4.*)</span><br><span class="line">  &#125; &gt; dram_seg</span><br><span class="line"></span><br><span class="line">  .data : &#123;</span><br><span class="line">    *(.data)</span><br><span class="line">    *(.data.*)</span><br><span class="line">    *(.gnu.linkonce.d.*)</span><br><span class="line">    *(.data1)</span><br><span class="line">    *(.sdata)</span><br><span class="line">    *(.sdata.*)</span><br><span class="line">    *(.gnu.linkonce.s.*)</span><br><span class="line">    *(.sdata2)</span><br><span class="line">    *(.sdata2.*)</span><br><span class="line">    *(.gnu.linkonce.s2.*)</span><br><span class="line">    *(.jcr)</span><br><span class="line">  &#125; &gt; dram_seg</span><br><span class="line"></span><br><span class="line">  .bss : &#123;</span><br><span class="line">    . = ALIGN (8);</span><br><span class="line">    _bss_start = ABSOLUTE(.);</span><br><span class="line">    *(.dynsbss)</span><br><span class="line">    *(.sbss)</span><br><span class="line">    *(.sbss.*)</span><br><span class="line">    *(.gnu.linkonce.sb.*)</span><br><span class="line">    *(.scommon)</span><br><span class="line">    *(.sbss2)</span><br><span class="line">    *(.sbss2.*)</span><br><span class="line">    *(.gnu.linkonce.sb2.*)</span><br><span class="line">    *(.dynbss)</span><br><span class="line">    *(.bss)</span><br><span class="line">    *(.bss.*)</span><br><span class="line">    *(.gnu.linkonce.b.*)</span><br><span class="line">    *(COMMON)</span><br><span class="line">    . = ALIGN (8);</span><br><span class="line">    _bss_end = ABSOLUTE(.);</span><br><span class="line">  &#125; &gt; dram_seg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里指定了 <code>main</code> 为首先执行的地址，也就是对应我们的 <code>main</code> 函数，当然如果你觉得 <code>main</code> 太普通了，你完全可以换成其它高大上的名称，这样入口函数就不是 <code>main</code> 了。另外值得一提的是我们这个链接脚本不支持 C++，要想支持 C++ 的话需要一些额外的段配置，且需要在程序运行初期进行 C++ 相关环境的布建，有兴趣的话，可以参考乐鑫的 bootloader 实现。</p>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>为了方便编译运行，我们还是在写一个 Makefile 吧，这样也算回归古老传统的 GNU 开发模式了：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILER_PREFIX := xtensa-esp32-elf</span><br><span class="line">CC := <span class="variable">$(CROSS_COMPILER_PREFIX)</span>-gcc</span><br><span class="line">LD := <span class="variable">$(CROSS_COMPILER_PREFIX)</span>-ld</span><br><span class="line">OBJDUMP := <span class="variable">$(CROSS_COMPILER_PREFIX)</span>-objdump</span><br><span class="line"></span><br><span class="line">FNAME := <span class="comment"># 这里填写最终生成的文件名</span></span><br><span class="line">OBJS +=  <span class="comment"># 这里填写需要参与链接的 .o 文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(FNAME)</span>.bin: <span class="variable">$(FNAME)</span>.elf</span><br><span class="line">	esptool.py --chip esp32 elf2image --flash_mode dio --flash_freq 40m --flash_size 2MB  -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(FNAME)</span>.elf: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(LD)</span> -Map <span class="variable">$(FNAME)</span>.map -Tesp32.lds -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line">	<span class="variable">$(OBJDUMP)</span> -D <span class="variable">$@</span> &gt; <span class="variable">$(FNAME)</span>.dis </span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -Wall -nostdlib -O2 -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">upload: <span class="variable">$(FNAME)</span>.bin</span></span><br><span class="line">	esptool.py --chip esp32 --baud 115200 --before default_reset --after hard_reset write_flash -z --flash_mode dio --flash_freq 40m --flash_size detect 0x1000 <span class="variable">$(FNAME)</span>.bin</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@rm -rf *.o *.elf *.dis *.bin *.map</span><br></pre></td></tr></table></figure>

<p>可以看到，在 <code>upload</code> 这条规则里，我们也是使用乐鑫官方的 <code>esptool.py</code> 工具，并指定了 Flash 地址为 <code>0x1000</code>。另外我们还生成了文件内存布局的 .map 描述文件，以及反编译后的 .dis 文件，用于查看配置是否正常。链接时，我们通过 <code>-T</code> 参数指定了链接脚本为 <code>esp32.lds</code>。到此，我们的裸机编译环境就构建完成了，下面可以开始着手写些代码了。</p>
<h1 id="构建运行环境"><a href="#构建运行环境" class="headerlink" title="构建运行环境"></a>构建运行环境</h1><p>看到这一小节的标题时，是不是有点讶异？还要构建啥运行环境？对，我们要构建下 C 语言和裸机程序的运行环境。对于 C 语言而言，一级引导程序帮助我们干掉了很多事情，比如栈指针的初始化、内存布局、处理器模式等，这些在后续点灯其它 MCU 时，我们可是需要自己手动操作的，这也是为什么我选择了 ESP32 作为第二季，不至于一次性干太多复杂的事情。对于 ESP32 而言，我们只要手动清理下 .bss 段，理论上就不需要做其它 C 语言相关环境布建的工作了。</p>
<p>前面说过了，SoC 复位后开启了看门狗，所谓的看门狗可以认为就是一个硬件模块，程序正常运行时我们需要不断的喂狗 (<em>通过操作喂狗寄存器</em>)，一段时间不喂狗的话，它就认为软件跑飞了，然后进行重启。不断喂狗比较麻烦，为了不被看门狗重启，我们需要手动关闭掉看门狗。</p>
<h2 id="寄存器的操作方式"><a href="#寄存器的操作方式" class="headerlink" title="寄存器的操作方式"></a>寄存器的操作方式</h2><p>在开始写代码前，因为之前并没有提及如何对寄存器进行读写，这里简单介绍两种方式。上一季已经说明过<strong>统一编址</strong>和<strong>独立编址</strong>了，现在大多数 MCU 都是采用了统一编址，所以操作它的寄存器就和访问主存的方式一直，比如我们查询手册后获取了一个寄存器地址为 <code>0x22332233</code>，进行读写操作的话，就可以直接转成一个 32位的指针进行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *reg = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x22332233</span>);</span><br><span class="line"><span class="type">int</span> v = *reg; <span class="comment">// 读</span></span><br><span class="line">*reg = <span class="number">2233</span>;  <span class="comment">// 写</span></span><br></pre></td></tr></table></figure>

<p>注意这里加上了 <code>volatile</code>，避免编译器优化缓存，而造成未真实的进行内存访问操作。一般常见的还有定义成宏的使用方式，具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REG *(volatile unsigned int *)(0x22332233)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = REG; <span class="comment">// 读</span></span><br><span class="line">REG = <span class="number">2233</span>;  <span class="comment">// 写</span></span><br></pre></td></tr></table></figure>

<p>除此之外，通过查阅手册不难发现，相关联的寄存器基本都定义在连续的地址空间了，那么我们就可以用结构体来描述一组相关联的寄存器了，大致模式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XXX_REG_BASE (0x22332233)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XXX_REG      ((XXX_REG_Def *)XXX_REG_BASE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *REG1;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *REG2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *REG3;</span><br><span class="line">&#125; XXX_REG_Def;</span><br></pre></td></tr></table></figure>

<p>按照上述的定义，我们访问寄存器的方式就是这样了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v = XXX_REG-&gt;REG1; <span class="comment">// 读</span></span><br><span class="line">XXX_REG-&gt;REG1 = <span class="number">2233</span>;  <span class="comment">// 写</span></span><br></pre></td></tr></table></figure>

<h2 id="清理-bss-段"><a href="#清理-bss-段" class="headerlink" title="清理 .bss 段"></a>清理 .bss 段</h2><p>在 <code>main</code> 这个入口函数开始，我们先清理下 .bss 段的数据，这里存放的是零初始化数据，比如 C 语言中的全局变量，清理方式比较简单，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> _bss_start;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> _bss_end;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bss_reset</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *start = &amp;_bss_start;</span><br><span class="line">    <span class="keyword">while</span> (start != &amp;_bss_end) &#123;</span><br><span class="line">        *start = <span class="number">0</span>;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    bss_reset();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里 <code>extern</code> 出来的两个变量，是我们在链接脚本 (<em>esp32.lds</em>) 里指定的，它们记录了整个 .bss 段的起始和截止位置，这边简单的遍历置零即可。</p>
<h2 id="关闭看门狗"><a href="#关闭看门狗" class="headerlink" title="关闭看门狗"></a>关闭看门狗</h2><p>这里一共有两条看门狗需要关闭，参考前面的内容：</p>
<blockquote>
<p>在 Flash 启动过程中，定时器组 0(TIMG0)中的 MWDT 和 RWDT 自动使能。两个看门狗定时器的阶段 0 默认为在超时后复位系统</p>
</blockquote>
<p>那么涉及到两组寄存器，按照手册的定义，我这边整理出了两个结构体，为了代码好看，这里还做了些预定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>       <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>      <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>        <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>  <span class="type">uint64_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span>         <span class="type">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">short</span>        <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">int</span>          <span class="type">int32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">long</span> <span class="type">long</span>    <span class="type">int64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTACT(x, y) _CONTACT(x, y) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CONTACT(x, y) x ## y</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __REG volatile</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __REG_RESERVE(count) __REG uint32_t CONTACT(__RESERVE, __LINE__) [count] </span></span><br></pre></td></tr></table></figure>

<p>以下则是两组寄存器的结构体了:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_CNTL_BASE       (0x3FF48000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMG0_BASE          (0x3FF5F000)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_CNTL    ((RTC_CNTL_Def *)RTC_CNTL_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMG0       ((TIMG_Def *)TIMG0_BASE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> OPTIONS0;        <span class="comment">// 0x3FF48000</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> SLP_TIMER0;      <span class="comment">// 0x3FF48004</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> SLP_TIMER1;      <span class="comment">// 0x3FF48008</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> TIME_UPDATE;     <span class="comment">// 0x3FF4800C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> TIME0;           <span class="comment">// 0x3FF48010</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> TIME1;           <span class="comment">// 0x3FF48014</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STATE0;          <span class="comment">// 0x3FF48018</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> TIMER1;          <span class="comment">// 0x3FF4801C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> TIMER2;          <span class="comment">// 0x3FF48020</span></span><br><span class="line">    __REG_RESERVE(<span class="number">2</span>);               <span class="comment">// 0x3FF48024 - 0x3FF48028 </span></span><br><span class="line">    __REG <span class="type">uint32_t</span> TIMER5;          <span class="comment">// 0x3FF4802C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> ANA_CONF;        <span class="comment">// 0x3FF48030</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> RESET_STATE;     <span class="comment">// 0x3FF48034</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WAKEUP_STATE;    <span class="comment">// 0x3FF48038</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> INT_ENA;         <span class="comment">// 0x3FF4803C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> INT_RAW;         <span class="comment">// 0x3FF48040</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> INT_ST;          <span class="comment">// 0x3FF48044</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> INT_CLR;         <span class="comment">// 0x3FF48048</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STORE0;          <span class="comment">// 0x3FF4804C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STORE1;          <span class="comment">// 0x3FF48050</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STORE2;          <span class="comment">// 0x3FF48054</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STORE3;          <span class="comment">// 0x3FF48058</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> EXT_XTL_CONF;    <span class="comment">// 0x3FF4805C </span></span><br><span class="line">    __REG <span class="type">uint32_t</span> EXT_WAKEUP_CONF; <span class="comment">// 0x3FF48060</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> SLP_REJECT_CONF; <span class="comment">// 0x3FF48064</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> CPU_PERIOD_CONF; <span class="comment">// 0x3FF48068</span></span><br><span class="line">    __REG_RESERVE(<span class="number">1</span>);               <span class="comment">// 0x3FF4806C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> CLK_CONF;        <span class="comment">// 0x3FF48070</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> SDIO_CONF;       <span class="comment">// 0x3FF48074 </span></span><br><span class="line">    __REG_RESERVE(<span class="number">1</span>);               <span class="comment">// 0x3FF48078 </span></span><br><span class="line">    __REG <span class="type">uint32_t</span> VREG;            <span class="comment">// 0x3FF4807C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> PWC;             <span class="comment">// 0x3FF48080</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> DIG_PWC;         <span class="comment">// 0x3FF48084</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> DIG_ISO;         <span class="comment">// 0x3FF48088</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTCONFIG0;      <span class="comment">// 0x3FF4808C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTCONFIG1;      <span class="comment">// 0x3FF48090</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTCONFIG2;      <span class="comment">// 0x3FF48094</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTCONFIG3;      <span class="comment">// 0x3FF48098</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTCONFIG4;      <span class="comment">// 0x3FF4809C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTFEED;         <span class="comment">// 0x3FF480A0</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTWPROTECT;     <span class="comment">// 0x3FF480A4</span></span><br><span class="line">    __REG_RESERVE(<span class="number">1</span>);               <span class="comment">// 0x3FF480A8 </span></span><br><span class="line">    __REG <span class="type">uint32_t</span> SW_CPU_STALL;    <span class="comment">// 0x3FF480AC</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STORE4;          <span class="comment">// 0x3FF480B0</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STORE5;          <span class="comment">// 0x3FF480B4</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STORE6;          <span class="comment">// 0x3FF480B8</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STORE7;          <span class="comment">// 0x3FF480BC</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> LOW_POWER_ST;    <span class="comment">// 0x3FF480C0 </span></span><br><span class="line">    __REG_RESERVE(<span class="number">1</span>);               <span class="comment">// 0x3FF480C4</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> HOLD_FORCE;      <span class="comment">// 0x3FF480C8</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> EXT_WAKEUP1;     <span class="comment">// 0x3FF480CC</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> EXT_WAKEUP1_STATUS; <span class="comment">// 0x3FF480D0</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> BROWN_OUT;       <span class="comment">// 0x3FF480D4</span></span><br><span class="line">&#125; __attribute__((packed)) RTC_CNTL_Def;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T0CONFIG;        <span class="comment">// 000</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T0LO;            <span class="comment">// 004</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T0HI;            <span class="comment">// 008</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T0UPDATE;        <span class="comment">// 00C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T0ALARMLO;       <span class="comment">// 010</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T0ALARMHI;       <span class="comment">// 014</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T0LOADLO;        <span class="comment">// 018</span></span><br><span class="line">    __REG_RESERVE(<span class="number">1</span>);               <span class="comment">// 01C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T0LOAD;          <span class="comment">// 020</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T1CONFIG;        <span class="comment">// 024</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T1LO;            <span class="comment">// 028</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T1HI;            <span class="comment">// 02C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T1UPDATE;        <span class="comment">// 030</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T1ALARMLO;       <span class="comment">// 034</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T1ALARMHI;       <span class="comment">// 038</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T1LOADLO;        <span class="comment">// 03C</span></span><br><span class="line">    __REG_RESERVE(<span class="number">1</span>);               <span class="comment">// 040</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> T1LOAD;          <span class="comment">// 044</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTCONFIG0;      <span class="comment">// 048</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTCONFIG1;      <span class="comment">// 04C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTCONFIG2;      <span class="comment">// 050</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTCONFIG3;      <span class="comment">// 054</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTCONFIG4;      <span class="comment">// 058</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTCONFIG5;      <span class="comment">// 05C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTFEED;         <span class="comment">// 060</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> WDTWPROTECT;     <span class="comment">// 064</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> RTCCALICFG;      <span class="comment">// 068</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> RTCCALICFG1;     <span class="comment">// 06C</span></span><br><span class="line">&#125; __attribute__((packed)) TIMG_Def;</span><br></pre></td></tr></table></figure>

<p>通过查阅手册，操作关闭看门狗寄存器前，需要先解除写保护，也就是对写保护寄存器写入一个特殊值：<code>0x050D83AA1</code>，具体关闭的代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wdt_close</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// close RTC watchdog </span></span><br><span class="line">    RTC_CNTL-&gt;WDTWPROTECT = <span class="number">0x050D83AA1</span>;</span><br><span class="line">    RTC_CNTL-&gt;WDTCONFIG0 = <span class="number">0</span>; </span><br><span class="line">    RTC_CNTL-&gt;WDTWPROTECT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close TIMG0 watchdog</span></span><br><span class="line">    TIMG0-&gt;WDTWPROTECT = <span class="number">0x050D83AA1</span>; </span><br><span class="line">    TIMG0-&gt;WDTCONFIG0 = <span class="number">0</span>;</span><br><span class="line">    TIMG0-&gt;WDTWPROTECT = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    bss_reset();</span><br><span class="line">    wdt_close();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>至此，我们的运行环境也布建完成了，为了验证我们的运行环境是否正常，我们可以简单来进行一下测试。</p>
<h2 id="运行环境测试"><a href="#运行环境测试" class="headerlink" title="运行环境测试"></a>运行环境测试</h2><p>前面部分有提到过，一级引导程序，也就是那段固化的代码，除了引导之外，还有一些实用方法可以使用，这些方法定义在 IDF 框架代码的 <code>esp32.rom.ld</code> 这个链接脚本文件里。我们挑选了延时以及串口打印函数来进行使用，在我们的 <code>esp32.lds</code> 链接文件里增加以下配置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROVIDE ( ets_printf = 0x40007d54 );</span><br><span class="line">PROVIDE ( ets_delay_us = 0x40008534 );</span><br><span class="line">PROVIDE ( ets_update_cpu_frequency_rom = 0x40008550 );</span><br></pre></td></tr></table></figure>

<p>让后再在相关头文件里将这些方法的原型定义出来:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ets_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ets_update_cpu_frequency_rom</span><span class="params">(<span class="type">uint32_t</span> ticks_per_us)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ets_delay_us</span><span class="params">(<span class="type">uint32_t</span> us)</span>;</span><br></pre></td></tr></table></figure>

<p>要使用延时函数的话，这里需要配置下 CPU 的频率，以及测试代码，具体如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    bss_reset();</span><br><span class="line">    wdt_close();</span><br><span class="line">    ets_update_cpu_frequency_rom(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ets_delay_us(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">        ets_printf(<span class="string">&quot;hello esp32, hello makee !\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将其 <code>make upload</code> 到开发板之后，可以通过 <code>screen</code> 命令进入串口，查看打印情况：</p>
<pre><code>screen /dev/cu.usbmodem533A0265041 115200
</code></pre>
<p>串口的地址，请跟进实际情况来更改，如果一切正常的话，可以看到以下这样的输出，并且大约是每秒一次:</p>
<p><img data-src="/images/2022/07/24/02-uart-output.png"></p>
<p>如此看来，初步验证是没有什么问题了，按下 <code>ctrl + A</code> 再按下 <code>ctrl + K</code> 退出串口终端，接下来就是激动人心的点灯时刻了。</p>
<h1 id="裸机点灯"><a href="#裸机点灯" class="headerlink" title="裸机点灯"></a>裸机点灯</h1><p>在正式点灯前，我们还是要看看今天要点的灯的硬件连接情况，主要是为了确定是通过哪个 IO 来进行操作。</p>
<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img data-src="/images/2022/07/24/03-rgb-sch.png"></p>
<p>这次要点的灯还比较高级，竟然是个 RGB 三色灯且有个外围驱动芯片 WS2812！通过原理图可以看到控制管脚接入到了 IO16，那么理论上我们通过这个 IO 相关寄存器就可以操作了。</p>
<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>在了解 WS2812 驱动前，我们先将需要的 IO 配置好，我这边也参考手册把 GPIO 相关的寄存器定义好了:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_BASE   (0x3FF44004)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO        ((GPIO_Def *)GPIO_BASE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> OUT;             <span class="comment">// 0x3FF44004</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> OUT_W1TS;        <span class="comment">// 0x3FF44008</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> OUT_W1TC;        <span class="comment">// 0x3FF4400C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> OUT1;            <span class="comment">// 0x3FF44010</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> OUT1_W1TS;       <span class="comment">// 0x3FF44014</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> OUT1_W1TC;       <span class="comment">// 0x3FF44018</span></span><br><span class="line">    __REG_RESERVE(<span class="number">1</span>);               <span class="comment">// 0x3FF4401C </span></span><br><span class="line">    __REG <span class="type">uint32_t</span> ENABLE;          <span class="comment">// 0x3FF44020</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> ENABLE_W1TS;     <span class="comment">// 0x3FF44024</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> ENABLE_W1TC;     <span class="comment">// 0x3FF44028</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> ENABLE1;         <span class="comment">// 0x3FF4402C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> ENABLE1_W1TS;    <span class="comment">// 0x3FF44030</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> ENABLE1_W1TC;    <span class="comment">// 0x3FF44034</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STRAP;           <span class="comment">// 0x3FF44038</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> IN;              <span class="comment">// 0x3FF4403C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> IN1;             <span class="comment">// 0x3FF44040</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STATUS;          <span class="comment">// 0x3FF44044</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STATUS_W1TS;     <span class="comment">// 0x3FF44048</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STATUS_W1TC;     <span class="comment">// 0x3FF4404C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STATUS1;         <span class="comment">// 0x3FF44050</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STATUS1_W1TS;    <span class="comment">// 0x3FF44054</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> STATUS1_W1TC;    <span class="comment">// 0x3FF44058</span></span><br><span class="line">    __REG_RESERVE(<span class="number">1</span>);               <span class="comment">// 0x3FF4405C </span></span><br><span class="line">    __REG <span class="type">uint32_t</span> ACPU_INT;        <span class="comment">// 0x3FF44060</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> ACPU_NMI_INT;    <span class="comment">// 0x3FF44064</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> PCPU_INT;        <span class="comment">// 0x3FF44068</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> PCPU_NMI_INT;    <span class="comment">// 0x3FF4406C</span></span><br><span class="line">    __REG_RESERVE(<span class="number">1</span>);               <span class="comment">// 0x3FF44070 </span></span><br><span class="line">    __REG <span class="type">uint32_t</span> ACPU_INT1;       <span class="comment">// 0x3FF44074</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> ACPU_NMI_INT1;   <span class="comment">// 0x3FF44078</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> PCPU_INT1;       <span class="comment">// 0x3FF4407C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> PCPU_NMI_INT1;   <span class="comment">// 0x3FF44080</span></span><br><span class="line">    __REG_RESERVE(<span class="number">1</span>);               <span class="comment">// 0x3FF44084</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> GPIO_PIN[<span class="number">40</span>];    <span class="comment">// 0x3FF44088 - 0x3FF44124</span></span><br><span class="line">    __REG_RESERVE(<span class="number">2</span>);               <span class="comment">// 0x3FF44128 - 0x3FF4412C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> FUNC_IN_SEL_CFG[<span class="number">256</span>];    <span class="comment">// 0x3FF44130 - 0x3FF4452C</span></span><br><span class="line">    __REG <span class="type">uint32_t</span> FUNC_OUT_SEL_CFG[<span class="number">40</span>];    <span class="comment">// 0x3FF44530 - 0x3FF445CC</span></span><br><span class="line">&#125; __attribute__((packed)) GPIO_Def;</span><br></pre></td></tr></table></figure>

<p>既然这个 IO16 最终是操控 WS2812 的，我们就新建一个 ws2812.h 和 ws2812.c 文件来进行相关代码编写吧。查阅寄存器手册，要初始化 IO 为输出模式，可以通过简单输出模式进行配置，操作以下两个寄存器即可:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RGB_PIN (16)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ws2812_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 配置 GPIO 输出使能置位寄存器</span></span><br><span class="line">    GPIO-&gt;ENABLE_W1TS = (<span class="number">1</span> &lt;&lt; RGB_PIN);</span><br><span class="line">    <span class="comment">// 配置 GPIO 外设输出选择寄存器</span></span><br><span class="line">    GPIO-&gt;FUNC_OUT_SEL_CFG[RGB_PIN] = <span class="number">0x100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 GPIO 的输出比较简单，也就是高电平和低电平，通过 ESP32 的 GPIO <strong>输出置位寄存器</strong>和<strong>输出清零寄存器</strong>即可:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作置位寄存器，输出 高电平</span></span><br><span class="line">GPIO-&gt;OUT_W1TS = (<span class="number">1</span> &lt;&lt; RGB_PIN);</span><br><span class="line"><span class="comment">// 操作清零寄存器，输出 低电平</span></span><br><span class="line">GPIO-&gt;OUT_W1TC = (<span class="number">1</span> &lt;&lt; RGB_PIN);</span><br></pre></td></tr></table></figure>

<p>注意，上面操作的寄存器，控制的是 0 - 31 号 IO，也就是相应的位操作即可控制相应的 IO，所以会有对应的移位操作。万事俱备了，就差怎么点亮这款高级的 RGB 灯了！</p>
<h2 id="WS2812-时序"><a href="#WS2812-时序" class="headerlink" title="WS2812 时序"></a>WS2812 时序</h2><p>对于和外围芯片进行通讯，我们经常会提到时序，那么什么是时序呢？首先我们从原理图中可以看到，这款芯片只靠一个 IO 就可以进行控制，如果高低电平分别表示 1 和 0 的话，那么一个 IO 只能表现出两种状态 0 或则 1，显然一个 RGB 颜色的灯，靠这两种状态肯定是不够的，那么怎么表现出更多状态呢？这就要引入另外一个分量，也就是时间，有了这个分量，我们就可以表现出无限的状态。比如我们将一个时间 T 划分成 8 份: t0-t7，在 t 这个时间段，如果 IO 电平为低则代表 0、IO 电平为高则代表 1，那么整个时间 T 内，我们就可以构造一个字节的数据 (<em>8 位</em>)。这就是大多数通讯协议的原理，比如串口、I2C、I2S、SPI 等，无非是其它的协议可能会多出一些时钟线和数据线，用来更快更精准的传输数据。在购买相关外围芯片时，厂家基本都会提供通讯的时序图，下面是 WS2812 的时序图:</p>
<p><img data-src="/images/2022/07/24/04-ws2812-sg.png"></p>
<p>简单来看，我们要输出 0 的话，就是在 TOH 这个时间段高电平，然后再在 T0L 这个时间段持续低电平，输出 1 的话类似。ws2812 的翻转时间比较短，在纳秒级别了，在 ESP32 里，我们可以通过空指令来实现一个大约的时间，于是写 1 和 写 0 的方法如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NOP do &#123; __asm__ __volatile__ (<span class="string">&quot;nop&quot;</span>); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ws2812_delay</span><span class="params">(<span class="type">short</span> num)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">short</span> j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">    NOP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ws2812_write_zero</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO-&gt;OUT_W1TS = (<span class="number">1</span> &lt;&lt; RGB_PIN);</span><br><span class="line">    ws2812_delay(<span class="number">6</span>);</span><br><span class="line">    GPIO-&gt;OUT_W1TC = (<span class="number">1</span> &lt;&lt; RGB_PIN);</span><br><span class="line">    ws2812_delay(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ws2812_write_one</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO-&gt;OUT_W1TS = (<span class="number">1</span> &lt;&lt; RGB_PIN);</span><br><span class="line">    ws2812_delay(<span class="number">32</span>);</span><br><span class="line">    GPIO-&gt;OUT_W1TC = (<span class="number">1</span> &lt;&lt; RGB_PIN);</span><br><span class="line">    ws2812_delay(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了写 0 和写 1 还不够，要想点亮 RGB，还要按照 ws2812 的芯片描述输出更多的数据:</p>
<p><img data-src="/images/2022/07/24/05-ws2812-sf.png"></p>
<p>可以看到，这里需要按照 GRB 的方式发送 24 位数据，那么也很简单，通过上面的方法在封装一下即可:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ws2812_write_byte</span><span class="params">(<span class="type">uint8_t</span> byte)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (byte &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">            ws2812_write_one();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ws2812_write_zero();</span><br><span class="line">        &#125;</span><br><span class="line">        byte &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ws2812_write_rgb</span><span class="params">(<span class="type">uint8_t</span> r, <span class="type">uint8_t</span> g, <span class="type">uint8_t</span> b)</span> &#123;</span><br><span class="line">   ws2812_write_byte(g);</span><br><span class="line">   ws2812_write_byte(r); </span><br><span class="line">   ws2812_write_byte(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们的 ws2812 驱动就完成了，可以点灯了！！！</p>
<h2 id="点灯效果"><a href="#点灯效果" class="headerlink" title="点灯效果"></a>点灯效果</h2><p>直接在 <code>main</code> 方法的起始地方进行调用即可:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    bss_reset();</span><br><span class="line">    wdt_close();</span><br><span class="line">    ets_update_cpu_frequency_rom(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    ws2812_init();</span><br><span class="line">    ws2812_write_rgb(<span class="number">0xFF</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 红色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ets_delay_us(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">        ets_printf(<span class="string">&quot;hello esp32, hello makee !\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例代码里，我们点成了红色，但你可以进行自行修改，理论上可以合成的颜色还是比较丰富的，下面是最基础的 R、G、B 三原色效果:</p>
<p><img data-src="/images/2022/07/24/06-lighting.png"></p>
<p>如果觉得刺眼的话，可以把色值相应的调低一点。那么这是我为你们点亮的第二盏灯，这是一个五彩缤纷的灯，也像这五彩的世界，期望你们不要在这五彩的世界里，迷失了那个单纯的自己。</p>
<h1 id="IDF-点灯"><a href="#IDF-点灯" class="headerlink" title="IDF 点灯"></a>IDF 点灯</h1><p>裸机点完了，那么使用 IDF 这种完备的框架来点灯的话，就要简单太多、太多了，具体直接看代码即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ws2812_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    gpio_pad_select_gpio(RGB_PIN);</span><br><span class="line">    gpio_reset_pin(RGB_PIN);</span><br><span class="line">    gpio_set_direction(RGB_PIN, GPIO_MODE_OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其余代码与寄存器版本一致 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ws2812_init();</span><br><span class="line">    ws2812_write_rgb(<span class="number">0xFF</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，除了 GPIO 的初始化，其它操作这里还是用了寄存器，因为使用框架的 <code>gpio_set_level</code> 来操作的话，时序上达不到 <code>ws2812</code> 的纳秒级别要求。当然，除了使用 GPIO，常规的驱动方式还是使用 PWM 波来，不过这不在我们这里的讨论范围了，使用 PWM 的话，相比于操作寄存器，框架层的封装就简单太多了。</p>
<h1 id="WOKWI-在线点灯"><a href="#WOKWI-在线点灯" class="headerlink" title="WOKWI 在线点灯"></a>WOKWI 在线点灯</h1><p>最后，我们来一次真正的在线点灯，可以打开网页: </p>
<p><a target="_blank" rel="noopener" href="https://wokwi.com/">https://wokwi.com</a></p>
<p>这里有一个可以在线仿真的编辑器，我们选择 ESP32 后，然后添加一下 <code>FreeRTOS</code>库，再在右侧连接一个简单的电路如下:</p>
<p><img data-src="/images/2022/07/24/07-online-con.png"></p>
<p>就可以使用 Arduino 框架进行在线点灯了:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *pt)</span> &#123;</span><br><span class="line">  pinMode(<span class="number">12</span>, OUTPUT);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    digitalWrite(<span class="number">12</span>, !digitalRead(<span class="number">12</span>));</span><br><span class="line">    vTaskDelay(<span class="number">800</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// put your setup code here, to run once:</span></span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  xTaskCreate(task1, <span class="string">&quot;LED BLINK&quot;</span>, <span class="number">1024</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有异常，会看到这个灯一闪一闪的，可以直接打开这个地址查看配置和效果:</p>
<p><a target="_blank" rel="noopener" href="https://wokwi.com/projects/337946979076145746">https://wokwi.com/projects/337946979076145746</a></p>
<p>关于 Arduino，这也是一个比较知名和强大的体系，使用起来很简单，但要细究其底层的封装，还是比较复杂的，有兴趣的可以自行去搜索学习！而 FreeRTOS 是一款现在已经非常流行的实时操作系统，提供了任务、队列、信号等功能，可以方便的构建出更健壮、通用的产品，这也是一个比较庞大的体系，这里还是点到为止，感兴趣的可以自行学习！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天的内容还是比较多的，那么我们稍微总结一下，本篇所涉及到或点到为止的内容：</p>
<ol>
<li>启动引导流程</li>
<li>应用内存布局</li>
<li>链接脚本</li>
<li>寄存器操作方式</li>
<li>裸机实现 ws2812 时序</li>
<li>Arduino、RTOS</li>
</ol>
<p>结束的有点仓促，想要总结的东西太多，但看了下时间也不早了，后面有时间我们再慢慢聊。无论如何，今天的灯亮了，这心也就定了。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2022/07/16/light-master-with-stc89c51/" rel="bookmark">点灯大师在线点灯之 STC89C51</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Light-Master/" rel="tag"># Light Master</a>
              <a href="/tags/ESP32/" rel="tag"># ESP32</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/16/light-master-with-stc89c51/" rel="prev" title="点灯大师在线点灯之 STC89C51">
      <i class="fa fa-chevron-left"></i> 点灯大师在线点灯之 STC89C51
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ESP32-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">ESP32 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E6%9D%BF%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">开发板简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%82%B9%E7%81%AF%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">点灯几种方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">启动流程分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="nav-number">5.</span> <span class="nav-text">构建编译环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC"><span class="nav-number">5.1.</span> <span class="nav-text">链接脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Makefile"><span class="nav-number">5.2.</span> <span class="nav-text">Makefile</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">6.</span> <span class="nav-text">构建运行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.</span> <span class="nav-text">寄存器的操作方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%85%E7%90%86-bss-%E6%AE%B5"><span class="nav-number">6.2.</span> <span class="nav-text">清理 .bss 段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="nav-number">6.3.</span> <span class="nav-text">关闭看门狗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95"><span class="nav-number">6.4.</span> <span class="nav-text">运行环境测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A3%B8%E6%9C%BA%E7%82%B9%E7%81%AF"><span class="nav-number">7.</span> <span class="nav-text">裸机点灯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="nav-number">7.1.</span> <span class="nav-text">原理图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GPIO"><span class="nav-number">7.2.</span> <span class="nav-text">GPIO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WS2812-%E6%97%B6%E5%BA%8F"><span class="nav-number">7.3.</span> <span class="nav-text">WS2812 时序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%82%B9%E7%81%AF%E6%95%88%E6%9E%9C"><span class="nav-number">7.4.</span> <span class="nav-text">点灯效果</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IDF-%E7%82%B9%E7%81%AF"><span class="nav-number">8.</span> <span class="nav-text">IDF 点灯</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WOKWI-%E5%9C%A8%E7%BA%BF%E7%82%B9%E7%81%AF"><span class="nav-number">9.</span> <span class="nav-text">WOKWI 在线点灯</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">10.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Makee"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Makee</p>
  <div class="site-description" itemprop="description">LIFE IS NOT EASY BUT HARD WORK ALWAYS PAYS.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/prinsun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;prinsun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/prinsun" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;prinsun" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Makee</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'FR2mSA60UEvzmYC24OgbdtvW-gzGzoHsz',
      appKey     : 'L70FAQa4gHBwVkjRwKJGajlx',
      placeholder: "欢迎留言交流...",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
